package transform

import (
	"github.com/snyk/go-application-framework/pkg/apiclients/testapi"

	"github.com/snyk/cli-extension-os-flows/internal/legacy/definitions"
)

// ConvertExploit translates Snyk API model to legacy JSON model.
func ConvertExploit(snykExploitDetails *testapi.SnykvulndbExploitDetails) (exploitDetails *definitions.ExploitDetails, exploit *string) {
	if len(snykExploitDetails.Sources) == 0 && len(snykExploitDetails.MaturityLevels) == 0 {
		return nil, nil
	}

	exploitDetails = &definitions.ExploitDetails{
		Sources: snykExploitDetails.Sources,
	}

	maturityLevels := make([]definitions.ExploitMaturityLevel, 0, len(snykExploitDetails.MaturityLevels))
	for _, matLevel := range snykExploitDetails.MaturityLevels {
		maturityLevels = append(maturityLevels, definitions.ExploitMaturityLevel{
			Format: matLevel.Format,
			Level:  MaturityLevelDisplayText(matLevel.Level),
			Type:   string(matLevel.Type),
		})
	}
	exploitDetails.MaturityLevels = maturityLevels

	return exploitDetails, primaryExploitMaturityLevel(exploitDetails.MaturityLevels)
}

// MaturityLevelDisplayText translates maturity level from the API model to the human-readable model used in the legacy JSON output.
func MaturityLevelDisplayText(code string) string {
	switch code {
	case "attacked":
		return "Attacked"
	case "functional":
		return "Functional"
	case "high":
		return "High"
	case "not defined":
		return "Not Defined"
	case "proof of concept":
		return "Proof of Concept"
	case "unproven":
		return "Unproven"
	case "unreported":
		return "Unreported"
	}

	return code
}

func primaryExploitMaturityLevel(maturityLevels []definitions.ExploitMaturityLevel) *string {
	for _, maturityLevel := range maturityLevels {
		if maturityLevel.Type == string(testapi.SnykvulndbCvssSourceTypePrimary) {
			return &maturityLevel.Level
		}
	}
	return nil
}
